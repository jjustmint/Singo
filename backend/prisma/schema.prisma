generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  user_id   Int         @id(map: "user_id") @default(autoincrement())
  username  String      @unique @db.VarChar(50)
  password  String
  user_key  String?     @db.VarChar(50)
  photo     String?     @db.VarChar
  recording recording[]
}

model song {
  song_id        Int             @id @default(autoincrement())
  title          String
  key_signature  String          @db.VarChar(50)
  parent_song_id Int?
  lyrics         String?
  audio_version  audio_version[]
  song           song?           @relation("songTosong", fields: [parent_song_id], references: [song_id], onDelete: Cascade, onUpdate: NoAction)
  other_song     song[]          @relation("songTosong")
}

model recording {
  record_id       Int            @id @default(autoincrement())
  user_id         Int?
  key             String?        @db.VarChar(50)
  user_audio_path String         @db.VarChar
  accuracy_score  Float?
  created_at      DateTime?      @default(now()) @db.Timestamp(6)
  version_id      Int?
  mistakes        mistakes[]
  User            User?          @relation(fields: [user_id], references: [user_id], onDelete: Cascade, onUpdate: NoAction)
  audio_version   audio_version? @relation(fields: [version_id], references: [version_id], onDelete: NoAction, onUpdate: NoAction, map: "recording_version_id_fk")
}

model audio_version {
  version_id    Int         @id(map: "songaudioversion_pkey") @default(autoincrement())
  song_id       Int?
  instru_path   String      @db.VarChar(50)
  ori_path      String?     @db.VarChar
  key_signature String      @db.VarChar(50)
  song          song?       @relation(fields: [song_id], references: [song_id], onDelete: Cascade, onUpdate: NoAction, map: "songaudioversion_song_id_fkey")
  recording     recording[]
}

model mistakes {
  missed_id       Int        @id(map: "missedpart_pkey") @default(autoincrement())
  recording_id    Int?
  timestamp_start Float?
  timestamp_end   Float?
  reason          String?    @db.VarChar(255)
  pitch_diff      Int?
  recording       recording? @relation(fields: [recording_id], references: [record_id], onDelete: Cascade, onUpdate: NoAction, map: "missedpart_recording_id_fkey")
}
